07 | 安全性、活跃性以及性能问题
https://time.geekbang.org/column/article/85702

活锁、饥饿
  活锁解决：线程随机一个等待时间，错开同时等待时间      
   
避免饥饿的条件：
        1、保证资源充足
        2、资源平均分配
        3、持有锁的线程执行时间过长
    ① 资源稀缺性没法保证；②持有锁线程的执行时间很难缩短；③保证资源分配 使用更公平锁 ，串行执行，顺序固定 访问平均
    （所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。）
  
  
  
评论内容：  
   
    关于活锁，看了老师举的例子还是不太明白。
    死锁是多个线程互相持有彼此需要的资源，形成依赖循环。
    活锁是多个线程类似死锁的情况下，同时释放掉自己已经获取的资源，然后同时获取另外一种资源，又形成依赖循环，导致都不能执行下去？不知道总结的对不对，老师可否点评一下？
    作者回复: 总结的对。就是同时放弃，然后又重试竞争，最后死循环在里面了。
    
 concurrentHashMap 在jdk 1.8之后没有sync+cas 分段锁了      
 
 吞吐量和并发量：
       吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。
       延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。
       并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。
       例如并发量是 1000 的时候，延迟是 50 毫秒。
    对于一个服务器来说，吞吐量是指server每秒钟能处理多少请求
    并发量：有多少客户端能同时访问     